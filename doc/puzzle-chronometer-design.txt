Design of a Puzzle Chronometer
------------------------------

The current "ChronometerMilli" implementation is, in essence, a simple
stop-watch: it starts, it stops, it reports an elapsed time, it gets reset, it
starts, its stops, etc. This is obviously the core functionality required for
an app that records solve times for puzzles, but it leaves a lot of other
required functionality to be implemented elsewhere. The "TimerFragment"
currently implements the inspection time functionality, which complicates what
should really be a component that presents a UI and glues the UI elements
together. This lack of neat encapsulation of the full timer functionality into
a single, abstracted API makes the code harder to maintain and poses a
significant challenge in the area of saving and restoring timer state. A new
design should address these issues.

The chronometer (let's call it the "timer", as that is easier to type)
responds to various touch inputs and to some time-out signals to drive it
through its states. The user can choose to enable "inspection time" before the
timer starts, can set the duration of the inspection time, can enable a visual
cue when the timer is ready to start, can enable a hold-to-start delay, can
start and stop the timer and can cancel (annul) the timer. Penalties can be
applied automatically (for overrunning the inspection time) or manually (after
the puzzle has been solved incompletely). The "TimerFragment" uses the
"ChronometerMilli" class (a "View") to manage the stop-watch element of this
process. Some of the post-solve penalties are now also supported by that
class. However, the fragment also hijacks the view to show the inspection
count-down, which complicates the view's own management of the display of its
elapsed time, and the solve time data is built into the view, making it hard
to implement some features, such as restoring the previous time of a
hold-to-start attempt is aborted. Clearly, this is not going to get any easier
to maintain.

A better approach would be to unify all of the timing functionality into one,
easy-to-test "PuzzleTimer" (or "PuzzleChronometer", if one prefers) API. A
useful design aspect would be to separate the operation of this timer from the
user interface. It should not be a View, but should be easy to "connect" to
views that supply the touch inputs and that display the time value. It would
handle the inspection period, the transition to the puzzle-solving phase
(including the hold-to-start and start-cue signals), the automatic
application of penalties, the recording of the solve time, and the handling of
post-solve penalties, cancellations, etc.

Separating a new timer from the UI would allow multiple timers to be
maintained. For example, the "old" timer for the previous solve could be
retained until the "new" timer for the current solve has started. This would
simplify the implementation of the "roll-back" required when inspection time
is not enabled and hold-to-start is aborted before the threshold touch
duration has elapsed. It would also allow the future implementation of
features, such as rolling back to the "old" time if the inspection period is
cancelled with the "Back" button, etc.

Separating the timer would also allow its implementation as a POJO and make it
easier to test using JUnit. The UI signals could be mocked up and the UI
updates could similarly be captured through an "observer" abstraction. The
timer would not connect directly to a "TextView", but would allow any class
implementing, say, "PuzzleTimerObserver" to be notified of the timer's
life-cycle events. JUnit testing would be a little bit complicated by the need
to measure elapsed time during testing. It would probably not be practical to
have tests running for up to several tens of seconds just to test one single
timer feature. It would also be more difficult to verify the operation, as the
elapsed times would be subject to a little bit of "jitter", due to the varying
system loads while tests are running and to timer precision. As a key goal
should be to have a reliable, bullet-proof core timer function, testability is
essential. Therefore, the design would probably benefit significantly from an
abstraction that separates the "clock" from the timer: driving the timer with
"ticks" that are generated externally. In production, this "clock" could be
the system clock and "CountDownTimer", while for testing, the "ticks" would
simply be generated by method calls from the test code. This would allow
precise control of the time signals and elapsed time that would be observed by
the "PuzzleTimer". For example, a simple "tickSeconds(15)" call would bring
the "PuzzleTimer" to the precise instant at the end of a 15-second inspection
period and its state could then be tested at leisure.


Requirements
------------

The new "PuzzleTimer" should integrate all of the necessary timing and penalty
functionality. This should be specified to meet the WCA regulations for timing
puzzle-solve attempts and applying penalties. It is useful to know what those
regulations are:

  Article 9: Events
    9f) The results of a round are measured as follows:
      9f1) All timed results under 10 minutes are measured and truncated to
           the nearest hundredth of a second. All timed averages and means
           under 10 minutes are measured and rounded to the nearest hundredth
           of a second.
      9f2) All timed results, averages, and means over 10 minutes are measured
           and rounded to the nearest second (e.g. x.4 becomes x, x.5 becomes
           x+1).
      9f4) The result of an attempt is recorded as DNF (Did Not Finish) if the
           attempt is disqualified or unsolved/unfinished.

By Article 9, the "PuzzleTimer" should be capable of delivering the time in an
appropriate format to the UI, or there should be some external implementation
that can perform the necessary rounding. Perhaps keeping it external is
better. The timer can simply record times with millisecond resolution and let
the UI handle the rounding at the time of presentation. Providing these
rounding functions as part of the delivery of the new functionality would be
useful, though.

While it is a little vague, this also suggests that the calculation of
averages should first round or truncate the results as described in Article 9
and only then calculate the average and round or truncate the average in the
same manner. This is beyond the scope of the core timer functionality, though.

  Article 10: Solved State
      10e) A puzzle is solved when all coloured parts are reassembled and all
           parts are aligned within the limits specified below:
        10e1) For each two adjacent parts (e.g. two parallel, adjacent slices
              of a cube) of the puzzle that are misaligned more than the limit
              described in Regulation 10f, the puzzle is considered to require
              one additional move to solve (see "Outer Block Turn Metric" in
              Article 12).
        10e2) If no further moves are required to bring the puzzle to its
              solved state, the puzzle is considered solved without penalty.
        10e3) If one move is required, the puzzle is be considered solved with
              a time penalty (+2 seconds).
        10e4) If more than one move is required, the puzzle is considered
              unsolved (DNF).

Article 10f) goes into details about what qualifies a move as "required", but
that is the responsibility of the user to apply after the solve. The import,
though, is that the timer should support the application of a "+2" or "DNF"
penalty after the timer is stopped. (This functionality is already present in
the application, as well as the ability to undo such a penalty, but it should
be fully integrated into the "PuzzleTimer" functionality.)

"Article A: Speed Solving" is where the key timer functionality needs to draw
its requirements:

  Article A: Speed Solving

    A1) Speed Solving attempts must abide by the following procedures.
        A1a) The organisation team must enforce time limits for attempts
             and/or rounds.
            A1a1) The default time limit per solve is 10 minutes, though the
                  organisation team may announce a higher or lower time limit.
            A1a2) Cumulative time limits may be enforced (e.g. 3 results with
                  a cumulative time limit of 20 minutes). The time elapsed in
                  a DNF result counts towards the cumulative time limit.
            A1a3) For each round, any time limits must be announced before the
                  round starts, and should not be changed after it has begun.
                  Changes must be made at the discretion of the WCA Delegate,
                  who must carefully consider the fairness of the change.
            A1a4) The competitor must end each solve within the time limit. If
                  a competitor reaches the time limit for a solve/round, the
                  judge stops the attempt immediately and records the result
                  as DNF. Exception: Multiple Blindfolded Solving (see
                  Regulation H1b1).
            A1a5) A solve is considered to meet the time limit if and only if
                  the final result, after any time penalties are applied, is
                  less than the time limit. Exception: Multiple Blindfolded
                  Solving (see Regulation H1b1).

The new timer should, even if not initially implemented, be capable of
supporting a maximum time limit and automatically applying a DNF penalty. If a
user solves a puzzle in, say, 9:59, but applies a +2 penalty, then the result
should be reported by the timer as a DNF penalty for running one second over
the maximum limit. The reason for making this requirement optional is that it
is not currently functionality that is found in the application, so it could
be left as an enhancement for some future time.

    A3) Inspection:
        A3a) The competitor may inspect the puzzle at the start of each
             attempt.
            A3a1) The competitor is allotted a maximum of 15 seconds to
                  inspect the puzzle and start the solve.
        A3c) The competitor may pick up the puzzle during inspection.
            A3c1) The competitor must not apply moves during inspection.
                  Penalty: disqualification of the attempt (DNF).
        A3d) At the end of the inspection, the competitor places the puzzle on
             the mat, in any orientation. Penalty for placing it outside the
             mat: time penalty (+2 seconds).
            A3d2) When 8 seconds of inspection have elapsed, the judge calls
                  "8 SECONDS".
            A3d3) When 12 seconds of inspection have elapsed, the judge calls
                  "12 SECONDS".

The new timer should integrate this inspection count-down functionality. The
current implementation does not support the manual application of DNF or +2
penalties during inspection, only their automatic application at the end of
inspection under other regulations (see later). The current implementation
also has no cues for these "8 SECONDS" and "12 SECONDS" calls. The timer
should fire events to its observer to support these. As the app supports
custom inspection durations, these events could be set to fire at 7 seconds
and 3 seconds before the end of whatever the inspection period is. If the
inspection period is exactly 7 seconds or 3 seconds long, then the event
should not fire at the instant that the inspection period starts, as that
would be redundant. These events could be captured by the fragment to effect a
visual and/or audible cue to alert the user.

There are regulations concerning the recording of did-not-start (DNS) solves,
but they are probably beyond the scope of a personal puzzle timer app.

    A4) Starting the solve:
        A4b) The competitor uses their fingers to touch the elevated sensor
             surfaces of the timer. The competitor's palms must be facing
             down, and located on the side of the timer that is closer to
             them. Penalty: time penalty (+2 seconds).
            A4b1) The competitor must have no physical contact with the puzzle
                  between the inspection period and the start of the solve.
                  Penalty: time penalty (+2 seconds).
        A4d) If a Stackmat timer is in use, the competitor starts the solve by
             confirming that the timer light is green and then removing their
             hands from the timer (thus starting the timer).
            A4d1) The competitor must start the solve within 15 seconds of the
                  start of the inspection. Penalty: time penalty (+2 seconds).
            A4d2) The competitor must start the solve within 17 seconds of the
                  start of the inspection. Penalty: disqualification of the
                  attempt (DNF).
            A4d3) If a stopwatch is in use, the judge starts the stopwatch as
                  soon as the competitor starts the solve.
        A4e) Time penalties for starting the solve are cumulative.

The current implementation supports the A4d1 and A4d2 penalties, but one of
its deficits is that it does not support cumulative "+2" penalties. In fact,
if a "+2" penalty is applied during inspection and then the user adds an extra
"+2" after stopping the timer and then hits "undo", the inspection penalty is
undone. The database records the penalties with simple flags, so it cannot
record more than one "+2" penalty and it cannot distinguish between penalties
applied at different times when undoing penalties, so this needs to be
addressed. Is there any real necessity to record "+2" in the database,
particularly when it serves no particular use? The DNF penalty is useful, as
it is a flag, but that could be recorded in a different manner, such as with a
negative time value. The "penalty" field in the database could be re-purposed
to report the cumulative total for all of the "+2" penalties. The value would
be zero if there were no penalties and it could be negative for DNF (rather
than using the "time" field).

After solving a puzzle, then, there could be a *list* of penalties that have
been applied, either automatically due to a time-out of the inspection period,
or manually by the users (who may be very honest about breaches of the
regulations and penalise themselves repeatedly during a solve). If there is an
"undo" facility for a final "+2", then there should probably be an "undo" for
any of the other penalties, except for the time-out penalties, maybe. Perhaps
this could be implemented as a simple "+2" and "-2", with the latter only able
to reverse penalties that were incurred manually. For example, if the solve
time is 1:30 and the inspection period ran to 16 seconds, then the solve is
given a +2 for the breach of A4d1. The user may also add, say, a penalty for
making a move during inspection (+2), and another for touching the cube after
leaving it down during inspection (+2) and another at the end for leaving one
move remaining (+2). Therefore there are +8 penalties and a -2 button could
"undo" only the latter three, reducing the penalties from +8 to +6 to +4 to
+2, but no lower. These penalties could then be added to the total time. In
the database, the penalty value (in seconds or milliseconds) would be stored
in the "penalty" field (with the "special" value for fake category name
records being changes to, say, -10 from +10) and -1 could represent a DNF. A
simple database upgrade pass could fix all of this for older records. The
"time" field would include the penalties, as that would make it easier to
manage. For example, the user might undo one of the four +2 penalties giving a
recorded "time" of 1:36 (136,000 ms) and a recorded "penalty" of +6.

    A5) During the solve:
        A5a) While inspecting or solving the puzzle, the competitor must not
             communicate with anyone other than the judge. Penalty:
             disqualification of the attempt (DNF).
        A5b) While inspecting or solving the puzzle, the competitor must not
             receive assistance from anyone or any object other than the
             surface (also see Regulation 2i). Penalty: disqualification of
             the attempt (DNF).
    A6) Stopping the solve:
        A6b) The competitor is responsible for stopping the Stackmat timer
             correctly.
            A6b1) If the timer stops before the end of the solve and the timer
                  shows a time strictly below 0.06 seconds, then the attempt
                  is replaced by an extra attempt. A competitor forfeits the
                  right to the additional attempt if the WCA Delegate
                  determines that the timer was stopped deliberately.
            A6b2) If the timer stops before the end of the solve and displays
                  a time of 0.06 seconds or higher, then the attempt is
                  disqualified (DNF). Exception: if the competitor can
                  demonstrate that the timer malfunctioned, they may receive
                  an extra attempt, at the discretion of the WCA Delegate.
        A6c) The competitor must fully release the puzzle before stopping the
             solve. Penalty: time penalty (+2 seconds).
        A6d) The competitor must stop the timer using both hands, placed flat
             on the sensors with palms down. Penalty: time penalty (+2s
             seconds).
        A6e) The competitor must not touch or move the puzzle until the judge
             has inspected the puzzle. Penalty: disqualification of the
             attempt (DNF). Exception: If no moves have been applied, a time
             penalty (+2 seconds) may be assigned instead, at the discretion
             of the judge.
        A6f) The competitor must not reset the timer until the judge has
             recorded the result on the score sheet. Penalty: disqualification
             of the attempt (DNF), at the discretion of the judge.
        A6i) Time penalties for stopping the solve are cumulative.

Again, by A6i, the time penalties are cumulative, so that needs to be
supported by the timer. The "0.06" (60 ms) timer limit is (I think)
implemented in the app in some manner, but it uses a limit of 80 ms.

    A7) Recording results:
        A7a) The judge tells the competitor the result.
            A7a1) If the judge finds that the puzzle is solved, they call
                  "OKAY".
            A7a2) If the judge assigns any penalties, they call "PENALTY".
            A7a3) If the result is DNF, the judge calls "DNF".

Like the calls during inspection, the timer should probably report these
states in the event it fires when the timer is stopped (or times out). Again,
they could be used by the fragment and UI for effects such as visual or
audible cues.

        A7b) The judge records the result on a score sheet.
            A7b1) If penalties are assigned, the judge records the original
                  recorded time displayed on the timer, along with any
                  penalties. The format should be "X + T + Y = F", where X
                  represents the sum of time penalties before/starting the
                  solve, T represents the time displayed on the timer (the
                  "original recorded time"), Y represents a sum of time
                  penalties during/after the solve, and F represents the final
                  result (e.g. 2 + 17.65 + 2 = 21.65). If X and/or Y is 0, the
                  0 terms are omitted (e.g. 17.65 + 2 = 19.65).

The new timer should provide the necessary information to report the solve
time in such a format. It will need to keep the X and Y penalties separate. It
may also need to not the +2 inspection time-out penalty, as that penalty
should not be allowed to be undone. All of the other penalties should be
allowed to be undone by the user, as the user will have applied them manually.

There is, of course, a complication to allowing a user to apply some penalties
during a solve: it might require multiple touch areas on the screen and this
could make the "smack-the-screen-anywhere-to-stop" obsolete and require
something with more finesse. This would probably not be a welcome change. As
the app is for timing personal solves, not an app that aspires to be used in
competitions by the WCA, the "PuzzleTimer" may allow penalties to be added at
any time, but the user-interface may impose its own "workflow" for usability
reasons.


TODO: How to handle "misfired events", such as a touch down that is later
interpreted as a swipe? Or a touch up that occurs after the timer has changed
to a different state, or has already stopped (the "holdingDNF" flag, whatever
that does)? This really only affect the hold-to-start functionality. Swiping
is not enabled when the timer is running. For hold-to-start, the timing of the
"hold" duration just needs to be cancelled. This will be essentially the same
as the current implementation, just with less clutter in the controller code.
